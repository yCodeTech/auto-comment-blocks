"use strict";
/* https://code.visualstudio.com/api/language-extensions/language-configuration-guide */

import * as vscode from "vscode";
import * as fs from "node:fs";
import * as path from "path";
import isWsl from "is-wsl";
import {IPackageJson} from "package-json-type";

import {Rules} from "./rules";
import {Logger} from "./logger";
import * as utils from "./utils";
import {ExtensionData} from "./extensionData";

export class Configuration {
	/**************
	 * Properties *
	 **************/

	/**
	 * The Logger class instance for logging messages to the Output Channel.
	 *
	 * @type {Logger}
	 */
	private logger: Logger;

	/**
	 * This extension data class instance.
	 * @type {ExtensionData}
	 */
	private extensionData: ExtensionData = new ExtensionData();

	/**
	 * A key:value Map object of language IDs and their config file paths.
	 */
	private languageConfigFilePaths = new Map<string, string>();

	/**
	 * A key:value Map object of language IDs and their configs.
	 */
	private readonly languageConfigs = new Map<string, vscode.LanguageConfiguration>();

	/**
	 * A key:value Map object of supported language IDs and their single-line style comments.
	 *
	 * @property {string} key Language ID.
	 * @property {string} value Style of line comment.
	 */
	private singleLineBlocksMap: Map<string, Map<string, string>> = new Map();

	/**
	 * A Map object of an array of supported language IDs for multi-line block comments.
	 *
	 * @property {string} key - "languages"
	 * @property {string[]} value - Array of language IDs.
	 */
	private multiLineBlocksMap: Map<string, string[]> = new Map();

	/**
	 * The directory where the auto-generated language definitions are stored.
	 * @type {string}
	 */
	private readonly autoGeneratedDir = `${__dirname}/../../auto-generated-language-definitions`;

	/**
	 * The file path for the single-line language definitions.
	 * @type {string}
	 */
	private readonly singleLineLangDefinitionFilePath = `${this.autoGeneratedDir}/single-line-languages.json`;

	/**
	 * The file path for the multi-line language definitions.
	 * @type {string}
	 */
	private readonly multiLineLangDefinitionFilePath = `${this.autoGeneratedDir}/multi-line-languages.json`;

	/***********
	 * Methods *
	 ***********/

	public constructor(logger: Logger) {
		this.logger = logger;

		// Always output extension information to channel on activate.
		this.logger.debug(`Extension details:`, this.extensionData.getAll());

		this.findAllLanguageConfigFilePaths();
		this.setLanguageConfigDefinitions();

		this.setMultiLineCommentLanguageDefinitions();
		this.setSingleLineCommentLanguageDefinitions();
		this.writeCommentLanguageDefinitionsToJsonFile();

		this.logDebugInfo();
	}

	/**
	 * Configure the comment blocks.
	 *
	 * @returns {vscode.Disposable[]}
	 */
	public configureCommentBlocks() {
		const disposables: vscode.Disposable[] = [];

		/**
		 * Auto-supported languages.
		 */

		const singleLineLangs = this.getSingleLineLanguages("supportedLanguages");
		const multiLineLangs = this.getMultiLineLanguages("supportedLanguages");

		// Setup the auto-supported single-line languages.
		for (let [langId, style] of singleLineLangs) {
			// If langId isn't disabled...
			if (!this.isLangIdDisabled(langId)) {
				// Set a bool if the single-line language also supports multi-line comments
				// (ie. the single-line language is also present in the multi-line map);
				let multiLine = multiLineLangs.includes(langId);
				disposables.push(this.setLanguageConfiguration(langId, multiLine, style));
			}
		}

		// Setup the auto-supported multi-line languages.
		for (let langId of multiLineLangs) {
			// If singleLineLangs doesn't have the langId, AND
			// the langId isn't set as disabled...
			if (!singleLineLangs.has(langId) && !this.isLangIdDisabled(langId)) {
				disposables.push(this.setLanguageConfiguration(langId, true));
			}
		}

		/**
		 * Custom-supported (unsupported) languages
		 */

		const customMultiLineLangs = this.getMultiLineLanguages("customSupportedLanguages");
		const customSingleLineLangs = this.getSingleLineLanguages("customSupportedLanguages");

		// Setup the custom-supported single-line languages, that are otherwise unsupported.
		for (let [langId, style] of customSingleLineLangs) {
			// If the langId isn't set as disabled...
			if (!this.isLangIdDisabled(langId)) {
				// Set a bool if the single-line language also supports multi-line comments
				// (ie. the single-line language is also present in the multi-line map);
				let multiLine = customMultiLineLangs.includes(langId);
				disposables.push(this.setLanguageConfiguration(langId, multiLine, style));
			}
		}

		// Setup the custom-supported multi-line languages, that are otherwise unsupported.
		for (let langId of customMultiLineLangs) {
			// If customSingleLineLangs doesn't have the langId AND
			// the langId isn't set as disabled...
			if (!customSingleLineLangs.has(langId) && !this.isLangIdDisabled(langId)) {
				disposables.push(this.setLanguageConfiguration(langId, true));
			}
		}

		return disposables;
	}

	/**
	 * Register some VSCode commands.
	 *
	 * @returns {vscode.Disposable[]}
	 */
	public registerCommands() {
		const singleLineBlockCommand = vscode.commands.registerTextEditorCommand("auto-comment-blocks.singleLineBlock", (textEditor, edit, args) => {
			this.handleSingleLineBlock(textEditor, edit);
		});
		const changeBladeMultiLineBlockCommand = vscode.commands.registerTextEditorCommand(
			"auto-comment-blocks.changeBladeMultiLineBlock",
			(textEditor, edit, args) => {
				this.handleChangeBladeMultiLineBlock(textEditor);
			}
		);
		return [singleLineBlockCommand, changeBladeMultiLineBlockCommand];
	}

	/**
	 * Sets the block comments for the blade language determined by the user setting.
	 *
	 * @param bladeOverrideComments A boolean indicating whether or not the user setting "Blade Override Comments" is enabled.
	 *
	 * @param [onStart=false] A boolean indicating whether or not the method was called
	 * on starting the extension.
	 * If `true`, it returns the comments, if `false` (default), it sets the comments to
	 * the language directly.
	 *
	 */
	public setBladeComments(bladeOverrideComments: boolean, onStart: boolean = false): any {
		// Is enabled AND blade langId is NOT set as disabled...
		if (bladeOverrideComments === true && !this.isLangIdDisabled("blade")) {
			if (onStart) {
				return ["{{--", "--}}"];
			} else {
				vscode.languages.setLanguageConfiguration("blade", {
					comments: {
						blockComment: ["{{--", "--}}"],
					},
				});
			}
		}
		// Is disabled OR blade langId is set as disabled...
		else if (!bladeOverrideComments || this.isLangIdDisabled("blade")) {
			if (onStart) {
				return ["<!--", "-->"];
			} else {
				vscode.languages.setLanguageConfiguration("blade", {
					comments: {
						blockComment: ["<!--", "-->"],
					},
				});
			}
		}
	}

	/**
	 * Get all the extension's configuration settings.
	 *
	 * @returns {vscode.WorkspaceConfiguration}
	 */
	public getConfiguration(): vscode.WorkspaceConfiguration {
		return vscode.workspace.getConfiguration(this.extensionData.get("name"), null);
	}

	/**
	 * Get value of the specified key from the extension's user configuration settings.
	 *
	 * @param {string} key The key of the specific setting.
	 *
	 * @returns {T} Returns the value of the `key`.
	 *
	 * NOTE: Return is typed as `T`, which is a generic type that represents the type that is declared when called (as explained in this StackOverflow answer: https://stackoverflow.com/a/49622066/2358222)
	 *
	 * @example ```ts
	 * this.getConfigurationValue<string[]>("disabledLanguages");
	 * ```
	 */
	public getConfigurationValue<T>(key: string): T {
		return this.getConfiguration().get<T>(key);
	}

	/**
	 * Update value of the specified key from the extension's user configuration settings.
	 *
	 * @param {string} key The key of the specific setting.

	 * @param {any} value The value to update the setting with.
	 *
	 * @example ```ts
	 * this.updateConfigurationValue("bladeOverrideComments", true);
	 * ```
	 */
	public updateConfigurationValue(key: string, value: any) {
		// .update(config key, new value, global)
		this.getConfiguration().update(key, value, true);
	}

	/**
	 * Is the language ID disabled?
	 * @param {string} langId Language ID
	 * @returns {boolean}
	 */
	public isLangIdDisabled(langId: string): boolean {
		return this.getConfigurationValue<string[]>("disabledLanguages").includes(langId);
	}

	/**
	 * Is the multi-line comment overridden for the specified language ID?
	 *
	 * @param {string} langId Language ID
	 * @returns {boolean}
	 */
	private isLangIdMultiLineCommentOverridden(langId: string): boolean {
		const overriddenList = this.getConfigurationValue<string[]>("overrideDefaultLanguageMultiLineComments");

		return overriddenList.hasOwnProperty(langId);
	}

	/**
	 * Get the overridden multi-line comment for the specified language ID.
	 *
	 * @param {string} langId Language ID
	 * @returns {string}
	 */
	private getOverriddenMultiLineComment(langId: string) {
		const overriddenList = this.getConfigurationValue<string[]>("overrideDefaultLanguageMultiLineComments");

		return overriddenList[langId];
	}

	/**
	 * Get an array of languages to skip, like plaintext, that don't have comment syntax
	 *
	 * Idea from this StackOverflow answer https://stackoverflow.com/a/72988011/2358222
	 *
	 * @returns {string[]}
	 */
	private getLanguagesToSkip(): string[] {
		const json = utils.readJsonFile(`${__dirname}/../../config/skip-languages.jsonc`);
		return json.languages;
	}

	/**
	 * Find all language config file paths from vscode installed extensions
	 * (built-in and 3rd party).
	 */
	private findAllLanguageConfigFilePaths() {
		const extensions: any[] = [];

		// If running in WSL...
		if (isWsl) {
			// Get the Windows user and built-in extensions paths.
			const windowsUserExtensionsPath = this.extensionData.get("WindowsUserExtensionsPathFromWsl");
			const windowsBuiltInExtensionsPath = this.extensionData.get("WindowsBuiltInExtensionsPathFromWsl");

			// Read the paths and create arrays of the extensions.
			const windowsBuiltInExtensions = this.readExtensionsFromDirectory(windowsBuiltInExtensionsPath);
			const windowsUserExtensions = this.readExtensionsFromDirectory(windowsUserExtensionsPath);

			// Combine the built-in and user extensions into the extensions array.
			extensions.push(...windowsBuiltInExtensions, ...windowsUserExtensions);
		}

		const userExtensionsPath = this.extensionData.get("userExtensionsPath");
		const builtInExtensionsPath = this.extensionData.get("builtInExtensionsPath");

		// Read the paths and create arrays of the extensions.
		const userExtensions = this.readExtensionsFromDirectory(userExtensionsPath);
		const builtInExtensions = this.readExtensionsFromDirectory(builtInExtensionsPath);

		// Add all installed extensions (including built-in ones) into the extensions array.
		// If running WSL, these will be the WSL-installed extensions.
		extensions.push(...builtInExtensions, ...userExtensions);

		// Loop through all installed extensions, including built-in extensions
		for (let extension of extensions) {
			const packageJSON: IPackageJson = extension.packageJSON;

			// If an extension package.json has "contributes" key,
			// AND the contributes object has "languages" key...
			if (Object.hasOwn(packageJSON, "contributes") && Object.hasOwn(packageJSON.contributes, "languages")) {
				// Loop through the languages...
				for (let language of packageJSON.contributes.languages) {
					// Get the languages to skip.
					let skipLangs = this.getLanguagesToSkip();

					// If skipLangs doesn't include the language ID,
					// AND the language object has "configuration" key...
					if (!skipLangs?.includes(language.id) && Object.hasOwn(language, "configuration")) {
						// Join the extension path with the configuration path.
						let configPath = path.join(extension.extensionPath, language.configuration);
						// Set the language ID and config path into the languageConfigFilePaths Map.
						this.languageConfigFilePaths.set(language.id, configPath);
					}
				}
			}
		}

		// Set the languageConfigFilePaths to a new map with all the languages sorted in
		// ascending order,for sanity reasons.
		this.languageConfigFilePaths = new Map([...this.languageConfigFilePaths].sort());
	}

	/**
	 * Set the language config definitions.
	 */
	private setLanguageConfigDefinitions() {
		this.languageConfigFilePaths.forEach((filepath, langId) => {
			const config = utils.readJsonFile(filepath);

			// If the config JSON has more than 0 keys (ie. not empty)
			if (Object.keys(config).length > 0) {
				/**
				 * Change all autoClosingPairs items that are using the simpler syntax
				 * (array instead of object) into the object with open and close keys.
				 * Prevents vscode from failing quietly and not changing the editor language
				 * properly, which makes the open file become unresponsive when changing tabs.
				 */

				// If config has key autoClosingPairs...
				if (Object.hasOwn(config, "autoClosingPairs")) {
					// Define a new array as the new AutoClosingPair.
					const autoClosingPairsArray: vscode.AutoClosingPair[] = [];
					// Loop through the config's autoClosingPairs...
					config.autoClosingPairs.forEach((item) => {
						// If the item is an array...
						if (Array.isArray(item)) {
							// Create a new object with the 1st array element [0] as the
							// value of the open key, and the 2nd element [1] as the value
							// of the close key.
							const autoClosingPairsObj = {open: item[0], close: item[1]};
							// Push the object into the new array.
							autoClosingPairsArray.push(autoClosingPairsObj);
						}
						// Otherwise, the item is an object, so just push it into the array.
						else {
							autoClosingPairsArray.push(item);
						}
					});

					// Add the new array to the config's autoClosingPairs key.
					config.autoClosingPairs = autoClosingPairsArray;
				}

				// Set the language configs into the Map.
				this.languageConfigs.set(langId, config);
			}
		});
	}

	/**
	 * Get the config of the specified language.
	 *
	 * @param langId Language ID
	 * @returns {vscode.LanguageConfiguration | undefined}
	 */
	private getLanguageConfig(langId: string) {
		if (this.languageConfigs.has(langId)) {
			return this.languageConfigs.get(langId);
		}
		// If no config exists for this language, back out and leave the language unsupported
		else {
			return undefined;
		}
	}

	/**
	 * Read the directory in the given path and return an array of objects with the data of
	 * all extensions found in the directory.
	 *
	 * @param {string} extensionsPath The path where extensions are stored.
	 *
	 * @returns {Array<{ id: string; extensionPath: string; packageJSON: IPackageJson }>}
	 */
	private readExtensionsFromDirectory(extensionsPath: string): Array<{id: string; extensionPath: string; packageJSON: IPackageJson}> {
		// Create an array to hold the found extensions.
		const foundExtensions: Array<{id: string; extensionPath: string; packageJSON: IPackageJson}> = [];

		fs.readdirSync(extensionsPath).forEach((extensionName) => {
			const extensionPath = path.join(extensionsPath, extensionName);

			// If the extensionName is a directory...
			if (fs.statSync(extensionPath).isDirectory()) {
				// If the extensionName starts with a dot, skip it.
				if (extensionName.startsWith(".")) {
					return;
				}

				// Get the package.json file path.
				const packageJSONPath = path.join(extensionPath, "package.json");

				// If the package.json file exists...
				if (fs.existsSync(packageJSONPath)) {
					const packageJSON: IPackageJson = utils.readJsonFile(packageJSONPath);

					const id = `${packageJSON.publisher}.${packageJSON.name}`;

					// Push the extension data object into the array.
					foundExtensions.push({id, extensionPath, packageJSON});
				}
			}
		});

		return foundExtensions;
	}

	/**
	 * Get the multi-line languages from the Map.
	 *
	 * @param {"supportedLanguages" | "customSupportedLanguages"} key A stringed key, either `"supportedLanguages"` or `"customSupportedLanguages"`
	 * @returns {string[]} An array of language ID strings.
	 */
	private getMultiLineLanguages(key: "supportedLanguages" | "customSupportedLanguages"): string[] {
		return this.multiLineBlocksMap.get(key);
	}

	/**
	 * Get the single-line languages and styles.
	 *
	 * @param {"supportedLanguages" | "customSupportedLanguages"} key A stringed key, either `"supportedLanguages"` or `"customSupportedLanguages"`
	 * @returns {Map<string, string>} The Map of the languages and styles.
	 */
	private getSingleLineLanguages(key: "supportedLanguages" | "customSupportedLanguages"): Map<string, string> {
		return this.singleLineBlocksMap.get(key);
	}

	/**
	 * Set the multi-line comments language definitions.
	 */
	private setMultiLineCommentLanguageDefinitions() {
		let langArray = [];

		this.languageConfigs.forEach((config: any, langId: string) => {
			// If the config object has own property of comments AND the comments key has
			// own property of blockComment...
			if (Object.hasOwn(config, "comments") && Object.hasOwn(config.comments, "blockComment")) {
				// If the blockComment array includes the multi-line start of "/*"...
				if (config.comments.blockComment.includes("/*")) {
					// console.log(langId, config.comments);

					// If Language ID isn't already in the langArray AND
					// the langId isn't set as disabled...
					if (!langArray.includes(langId) && !this.isLangIdDisabled(langId)) {
						// Add it to the array.
						langArray.push(langId);
					}
				}
			}
		});

		// Set the supportedLanguages array into the multiLineBlockMap, sorted in ascending order,
		// for sanity reasons.
		this.multiLineBlocksMap.set("supportedLanguages", langArray.sort());

		const multiLineStyleBlocksLangs = this.getConfigurationValue<string[]>("multiLineStyleBlocks");

		// Empty the langArray to reuse it.
		langArray = [];
		for (let langId of multiLineStyleBlocksLangs) {
			// If langId is exists (ie. not NULL or empty string) AND
			// the array doesn't already include langId, AND
			// the langId isn't set as disabled...
			if (langId && !langArray.includes(langId) && !this.isLangIdDisabled(langId)) {
				// Add it to the array.
				langArray.push(langId);
			}
		}
		// Set the customSupportedLanguages array into the multiLineBlockMap,
		// sorted in ascending order, for sanity reasons.
		this.multiLineBlocksMap.set("customSupportedLanguages", langArray.sort());
	}

	/**
	 * Set the single-line comments language definitions.
	 */
	private setSingleLineCommentLanguageDefinitions() {
		let style: string;
		const tempMap: Map<string, string> = new Map();
		this.languageConfigs.forEach((config: any, langId: string) => {
			// console.log(langId, config.comments.lineComment);
			let style: string = "";

			// If the config object has own property of comments AND the comments key has
			// own property of lineComment...
			if (Object.hasOwn(config, "comments") && Object.hasOwn(config.comments, "lineComment")) {
				let lineComment = config.comments.lineComment;

				// Line comments can be a string or an object with a "comment" key.
				// If the lineComment is an object, get the "comment" key value.
				if (Object.hasOwn(lineComment, "comment")) {
					lineComment = lineComment.comment;
				}

				// If the lineComment is "//"...
				if (lineComment === "//") {
					style = "//";
				}
				// If the lineComment is "#"...
				else if (lineComment === "#") {
					style = "#";
				}
				// If the lineComment includes a ";" (; or ;;)...
				else if (lineComment.includes(";")) {
					style = ";";
				}

				// If style is NOT an empty string, (i.e. not an unsupported single-line
				// comment like bat's @rem), AND
				// the langId isn't set as disabled...
				if (style != "" && !this.isLangIdDisabled(langId)) {
					// Set the langId and it's style into the Map.
					tempMap.set(langId, style);
				}
			}
		});

		// Set the supportedLanguages tempMap into the singleLineBlocksMap,
		// sorted in ascending order, for sanity reasons.
		this.singleLineBlocksMap.set("supportedLanguages", new Map([...tempMap].sort()));

		// Empty the tempMap to reuse it.
		tempMap.clear();

		// Get user-customized langIds for the //-style and add to the map.
		let customSlashLangs = this.getConfigurationValue<string[]>("slashStyleBlocks");
		for (let langId of customSlashLangs) {
			// If langId is exists (ie. not NULL or empty string) AND
			// the langId is longer than 0, AND
			// the langId isn't set as disabled...
			if (langId && langId.length > 0) {
				tempMap.set(langId, "//");
			}
		}

		// Get user-customized langIds for the #-style and add to the map.
		let customHashLangs = this.getConfigurationValue<string[]>("hashStyleBlocks");
		for (let langId of customHashLangs) {
			// If langId is exists (ie. not NULL or empty string) AND
			// the langId is longer than 0, AND
			// the langId isn't set as disabled...
			if (langId && langId.length > 0 && !this.isLangIdDisabled(langId)) {
				tempMap.set(langId, "#");
			}
		}

		// Get user-customized langIds for the ;-style and add to the map.
		let customSemicolonLangs = this.getConfigurationValue<string[]>("semicolonStyleBlocks");
		for (let langId of customSemicolonLangs) {
			// If langId is exists (ie. not NULL or empty string) AND
			// the langId is longer than 0, AND
			// the langId isn't set as disabled...
			if (langId && langId.length > 0 && !this.isLangIdDisabled(langId)) {
				tempMap.set(langId, ";");
			}
		}

		// Set the customSupportedLanguages tempMap into the singleLineBlocksMap,
		// sorted in ascending order, for sanity reasons.
		this.singleLineBlocksMap.set("customSupportedLanguages", new Map([...tempMap].sort()));
	}

	/**
	 * Write Comment Language Definitions to the respective JSON file:
	 * either multi-line-languages.json, or single-line-languages.json.
	 */
	private writeCommentLanguageDefinitionsToJsonFile() {
		// Ensure the auto-generated directory exists.
		utils.ensureDirExists(this.autoGeneratedDir);

		// Write the into the single-line-languages.json file.
		utils.writeJsonFile(this.singleLineLangDefinitionFilePath, utils.convertMapToReversedObject(this.singleLineBlocksMap));
		// Write the into the multi-line-languages.json file.
		utils.writeJsonFile(this.multiLineLangDefinitionFilePath, Object.fromEntries(this.multiLineBlocksMap));
	}

	/**
	 * Sets the language configuration for a given language ID.
	 *
	 * @param {string} langId - The language ID for which the configuration is being set.
	 * @param {boolean} multiLine - Optional. If true, sets multi-line comment configuration.
	 * @param {string} singleLineStyle - Optional. Specifies the style of single-line comments (e.g., "//", "#", ";").
	 *
	 * @returns {vscode.Disposable}
	 *
	 * This method performs the following tasks:
	 * - Retrieves the internal language configuration for the specified language ID.
	 * - Reads the default multi-line configuration from a JSON file.
	 * - Merges the default multi-line configuration with the internal language configuration if
	 *   multiLine is `true`.
	 * - Sets the appropriate comment styles and onEnter rules.
	 * - Reconstructs regex patterns for onEnterRules, wordPattern, folding markers, and
	 *   indentation rules to ensure they are in RegExp form.
	 * - Sets the final language configuration to VScode to use.
	 *
	 * Note: This method ensures that the language configuration is correctly set and avoids issues
	 * with rogue characters being inserted on new lines.
	 */
	private setLanguageConfiguration(langId: string, multiLine?: boolean, singleLineStyle?: string): vscode.Disposable {
		const internalLangConfig: vscode.LanguageConfiguration = this.getLanguageConfig(langId);
		const defaultMultiLineConfig: any = utils.readJsonFile(`${__dirname}/../../config/default-multi-line-config.json`);

		let langConfig = {...internalLangConfig};

		if (multiLine) {
			langConfig.autoClosingPairs = utils.mergeArraysBy(defaultMultiLineConfig.autoClosingPairs, internalLangConfig?.autoClosingPairs, "open");

			// Add the multi-line onEnter rules to the langConfig.
			langConfig.onEnterRules = utils.mergeArraysBy(Rules.multilineEnterRules, internalLangConfig?.onEnterRules, "beforeText");

			// Only assign the default config comments if it doesn't already exist.
			// (nullish assignment operator ??=)
			langConfig.comments ??= defaultMultiLineConfig.comments;

			// If the default multi-line comments has been overridden for the langId,
			// add the overridden multi-line comments to the langConfig.
			if (this.isLangIdMultiLineCommentOverridden(langId)) {
				langConfig.comments.blockComment[0] = this.getOverriddenMultiLineComment(langId);
			}

			/**
			 * Get the user settings/configuration and set the blade or html comments accordingly.
			 */
			if (langId === "blade") {
				langConfig.comments.blockComment = this.setBladeComments(this.getConfigurationValue<boolean>("bladeOverrideComments"), true);
			}
		}

		let isOnEnter = this.getConfigurationValue<boolean>("singleLineBlockOnEnter");

		// Add the single-line onEnter rules to the langConfig.
		//
		// If isOnEnter is true AND singleLineStyle isn't false, i.e. is a string,
		// then merge and set the rules.
		if (isOnEnter && singleLineStyle) {
			// //-style comments
			if (singleLineStyle === "//") {
				langConfig.onEnterRules = utils.mergeArraysBy(Rules.slashEnterRules, langConfig?.onEnterRules, "beforeText");
			}
			// #-style comments
			else if (singleLineStyle === "#") {
				langConfig.onEnterRules = utils.mergeArraysBy(Rules.hashEnterRules, langConfig?.onEnterRules, "beforeText");
			}
			// ;-style comments
			else if (singleLineStyle === ";") {
				langConfig.onEnterRules = utils.mergeArraysBy(Rules.semicolonEnterRules, langConfig?.onEnterRules, "beforeText");
			}
		}
		// If isOnEnter is false AND singleLineStyle isn't false, i.e. a string.
		else if (!isOnEnter && singleLineStyle) {
			// If langConfig does NOT have a comments key OR
			// the comments key exists but does NOT have the lineComment key...
			if (!Object.hasOwn(langConfig, "comments") || !Object.hasOwn(langConfig.comments, "lineComment")) {
				// Add the singleLineStyle to the lineComments key and make sure any
				// blockComments aren't overwritten.
				langConfig.comments = {...langConfig.comments, lineComment: singleLineStyle};
			}
		}

		// Reconstruct the regex patterns for the onEnterRules.
		// This is required because the onEnterRules are not working in some languages.
		// The issue is that the onEnterRules are not being set correctly, and are not
		// being used by vscode.

		// Fixes rogue * being inserted on to an empty line when pressing tab when the line
		// * above is a single-line comment. A rogue * also gets inserted when the any new
		// line after any kind of code except multi-line comments.

		// Check if isOnEnter OR multiline is true.
		if (isOnEnter || multiLine) {
			langConfig.onEnterRules.forEach((item) => {
				// Check if the item has a "beforeText" property and reconstruct its regex pattern.
				if (Object.hasOwn(item, "beforeText")) {
					item.beforeText = utils.reconstructRegex(item, "beforeText");
				}
				// Check if the item has an "afterText" property and reconstruct its regex pattern.
				if (Object.hasOwn(item, "afterText")) {
					item.afterText = utils.reconstructRegex(item, "afterText");
				}
				// Check if the item has an "afterText" property and reconstruct its regex pattern.
				if (Object.hasOwn(item, "previousLineText")) {
					item.previousLineText = utils.reconstructRegex(item, "previousLineText");
				}
			});
		}

		// Make sure wordPattern is in RegExp form instead of a string, otherwise vscode errors out:
		// > TypeError: e.exec is not a function
		//
		// The extension won't activate when there's a wordPattern key with a string regex in the config when using `setLanguageConfiguration()`.
		//
		// It's unknown why the allowed regex as string causes this, there seems to be a similar, related issue in https://github.com/microsoft/vscode/issues/171194 but was closed as (wrongly?) an invalid issue.
		//
		// So we're just changing the string to an actual regex pattern.

		// If langConfig has a wordPattern key...
		if (Object.hasOwn(langConfig, "wordPattern")) {
			langConfig.wordPattern = utils.reconstructRegex(langConfig, "wordPattern");
		}
		// If langConfig has a folding key...
		if (Object.hasOwn(langConfig, "folding")) {
			// @ts-ignore error TS2339: Property 'folding' does not exist on type
			if (Object.hasOwn(langConfig.folding, "markers")) {
				// @ts-ignore error TS2339: Property 'folding' does not exist on type
				langConfig.folding.markers.start = utils.reconstructRegex(langConfig.folding.markers, "start");

				// @ts-ignore error TS2339: Property 'folding' does not exist on type
				langConfig.folding.markers.end = utils.reconstructRegex(langConfig.folding.markers, "end");
			}
		}
		// If langConfig has a indentationRules key...
		if (Object.hasOwn(langConfig, "indentationRules")) {
			let indentationRules = langConfig.indentationRules;

			// Loop through the indentationRules object...
			for (let key in indentationRules) {
				// If the key is "increaseIndentPattern", reconstruct the regex pattern.
				if (key === "increaseIndentPattern") {
					indentationRules.increaseIndentPattern = utils.reconstructRegex(indentationRules, "increaseIndentPattern");
				}
				// If the key is "decreaseIndentPattern", reconstruct the regex pattern.
				if (key === "decreaseIndentPattern") {
					indentationRules.decreaseIndentPattern = utils.reconstructRegex(indentationRules, "decreaseIndentPattern");
				}
				// If the key is "indentNextLinePattern", reconstruct the regex pattern.
				if (key === "indentNextLinePattern") {
					indentationRules.indentNextLinePattern = utils.reconstructRegex(indentationRules, "indentNextLinePattern");
				}
				// If the key is "unIndentedLinePattern", reconstruct the regex pattern.
				if (key === "unIndentedLinePattern") {
					indentationRules.unIndentedLinePattern = utils.reconstructRegex(indentationRules, "unIndentedLinePattern");
				}
			}
		}

		// If langConfig doesn't have an indentationRules key, then we need to add it with
		// empty strings.
		//
		// Prevents a single-line comment being inserted when pressing `tab` after immediately
		// breaking out of a comment block. Seems to only happen with languages without
		// indentationRules.
		else {
			langConfig.indentationRules = {
				// @ts-ignore error TS2322: Type 'string' is not assignable to type 'RegExp'.
				increaseIndentPattern: "",
				// @ts-ignore error TS2322: Type 'string' is not assignable to type 'RegExp'.
				decreaseIndentPattern: "",
			};
		}

		this.logger.debug(`The language config for ${langId}:`, langConfig);

		return vscode.languages.setLanguageConfiguration(langId, langConfig);
	}

	/**
	 * The keyboard binding event handler for the single-line blocks on shift+enter.
	 *
	 * @param {vscode.TextEditor} textEditor The text editor.
	 * @param {vscode.TextEditorEdit} edit The text editor edits.
	 */
	private handleSingleLineBlock(textEditor: vscode.TextEditor, edit: vscode.TextEditorEdit) {
		let langId = textEditor.document.languageId;
		const singleLineLangs = this.getSingleLineLanguages("supportedLanguages");
		const customSingleLineLangs = this.getSingleLineLanguages("customSupportedLanguages");

		// Get the langId from the auto-supported langs. If it doesn't exist, try getting it from
		// the custom-supported langs instead.
		var style = singleLineLangs.get(langId) ?? customSingleLineLangs.get(langId);

		if (style && textEditor.selection.isEmpty) {
			let line = textEditor.document.lineAt(textEditor.selection.active);
			let isCommentLine = true;
			var indentRegex: RegExp;

			if (style === "//" && line.text.search(/^\s*\/\/\s*/) !== -1) {
				indentRegex = /\//;
				if (line.text.search(/^\s*\/\/\//) !== -1) {
					style = "///";
				}
				if (line.text.search(/^\s*\/\/!/) !== -1) {
					style = "//!";
				}
			} else if (style === "#" && line.text.search(/^\s*#\s*/) !== -1) {
				indentRegex = /#/;
				if (line.text.search(/^\s*##/) !== -1) {
					style = "##";
				}
			} else if (style === ";" && line.text.search(/^\s*;\s*/) !== -1) {
				indentRegex = /;/;

				// If text is ;;, then change the style from single ; to double ;;.
				if (line.text.search(/^\s*;;/) !== -1) {
					style = ";;";
				}
			} else {
				isCommentLine = false;
			}

			if (!isCommentLine) {
				return;
			}

			var indentedNewLine = "\n" + line.text.substring(0, line.text.search(indentRegex));
			let isOnEnter = this.getConfigurationValue<boolean>("singleLineBlockOnEnter");
			if (!isOnEnter) {
				indentedNewLine += style + " ";
			}

			edit.insert(textEditor.selection.active, indentedNewLine);
		}
	}

	/**
	 * The keyboard binding event handler to change between the multi-line block comments for
	 * blade `{{--  --}}` and normal `<!-- -->`
	 *
	 * @param {vscode.TextEditor} textEditor The text editor.
	 */
	private handleChangeBladeMultiLineBlock(textEditor: vscode.TextEditor) {
		let langId = textEditor.document.languageId;
		const extensionName = this.extensionData.get("name");

		// Only carry out function if languageId is blade.
		if (langId === "blade" && !this.isLangIdDisabled(langId)) {
			// Read current value
			let isOverridden = this.getConfigurationValue<boolean>("bladeOverrideComments");

			if (isOverridden === false) {
				// Update to true
				this.updateConfigurationValue("bladeOverrideComments", true);
			} else {
				// Update to false
				this.updateConfigurationValue("bladeOverrideComments", false);
			}
			// Read new value
			let bladeOverrideComments = this.getConfigurationValue<boolean>("bladeOverrideComments");

			// Set the comments for blade language.
			this.setBladeComments(bladeOverrideComments);
		}
		// If langId is blade AND Blade is set as disabled in the settings,
		// then output a message to the user.
		else if (langId == "blade" && this.isLangIdDisabled(langId)) {
			vscode.window.showInformationMessage(
				`Blade is set as disabled in the "${extensionName}.disabledLanguages" setting. The "${extensionName}.bladeOverrideComments" setting will have no affect.`,
				"OK"
			);

			// Set the comments for blade language.
			this.setBladeComments(false);
		}
	}

	/**
	 * Logs the environment, configuration settings, and language configs for debugging purposes.
	 */
	private logDebugInfo() {
		// The path to the built-in extensions. The env variable changes when on WSL.
		// So we can use it for both Windows and WSL.
		const builtInExtensionsPath = this.extensionData.get("builtInExtensionsPath");

		let extensionsPaths = {};

		if (isWsl) {
			// Get the Windows user and built-in extensions paths.
			const windowsUserExtensionsPath = this.extensionData.get("WindowsUserExtensionsPathFromWsl");
			const windowsBuiltInExtensionsPath = this.extensionData.get("WindowsBuiltInExtensionsPathFromWsl");

			extensionsPaths = {
				"Windows-installed Built-in Extensions Path": windowsBuiltInExtensionsPath,
				"Windows-installed User Extensions Path": windowsUserExtensionsPath,
				"WSL-installed Built-in Extensions Path": builtInExtensionsPath,
				"WSL-installed User Extensions Path": this.extensionData.get("userExtensionsPath"),
			};
		} else {
			extensionsPaths = {
				"Built-in Extensions Path": builtInExtensionsPath,
				"User Extensions Path": this.extensionData.get("userExtensionsPath"),
			};
		}

		const env = {
			"OS": process.platform,
			"Platform": process.platform,
			"VS Code Details": {
				"Version": vscode.version,
				"Remote Name": vscode.env.remoteName || "local",
				"Host": vscode.env.appHost,
				...extensionsPaths,
			},
			"Other System Env Variables": process.env,
		};
		this.logger.debug("Environment:", env);

		// Log the extension's user configuration settings.
		this.logger.debug("Configuration settings:", this.getConfiguration());

		// Log the objects for debugging purposes.
		this.logger.debug("The language config filepaths found are:", this.languageConfigFilePaths);
		this.logger.debug("The language configs found are:", this.languageConfigs);
		this.logger.debug("The supported languages for multi-line blocks:", utils.readJsonFile(this.multiLineLangDefinitionFilePath));
		this.logger.debug("The supported languages for single-line blocks:", utils.readJsonFile(this.singleLineLangDefinitionFilePath));
	}
}
